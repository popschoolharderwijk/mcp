---
alwaysApply: true
---

* When writing tests, never start a test by deleting data to get rid of potential dirty database states. A dirty database state means some other test didn't properly clean up. THAT needs to be fixed instead.
* Use the database state verification helpers from `tests/rls/db-state.ts` in `beforeAll()` and `afterAll()` to verify database integrity after tests complete.
* Try to use these integrity checks for all written test files, unless the expected data is too large (e.g., seed data that grows over time).
* You can also use these helpers for debugging purposes to identify which tables/rows were modified unexpectedly.

Example usage:
```typescript
import { beforeAll, afterAll, expect } from 'bun:test';
import { captureDatabaseState, compareDatabaseStates } from '../db-state';

describe('My test suite', () => {
  let initialState: DatabaseState;

  beforeAll(async () => {
    initialState = await captureDatabaseState();
  });

  afterAll(async () => {
    const finalState = await captureDatabaseState();
    const comparison = compareDatabaseStates(initialState, finalState);
    
    expect(comparison.equal).toBe(true);
    if (!comparison.equal) {
      console.error('Database state changed:', comparison.differences);
    }
  });

  // ... your tests ...
});
```