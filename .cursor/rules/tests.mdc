---
alwaysApply: true
---

* When writing tests, never start a test by deleting data to get rid of potential dirty database states. A dirty database state means some other test didn't properly clean up. THAT needs to be fixed instead.
* **Seed data is authoritative**: All tests must rely on data from `supabase/seed.sql`. Every test can assume that seed data is available and consistent. If test data is needed, add it to `supabase/seed.sql` instead of creating it in tests.
* **Tests may modify the database**: Tests are allowed to create, modify, or delete data during execution (e.g., for INSERT/UPDATE/DELETE permission tests). However, tests MUST restore the database to its original state after completion. Use the `setupDatabaseStateVerification()` helper from `tests/rls/db-state.ts` to automatically verify that the database state is unchanged after tests run.
* Use the `setupDatabaseStateVerification()` helper from `tests/rls/db-state.ts` to automatically verify database integrity after tests complete. This helper captures the initial state in `beforeAll()` and verifies it hasn't changed in `afterAll()`.
* Try to use these integrity checks for all written test files, unless the expected data is too large (e.g., seed data that grows over time).
* You can also use these helpers for debugging purposes to identify which tables/rows were modified unexpectedly.

Example usage:
```typescript
import { afterAll, beforeAll, describe, expect, it } from 'bun:test';
import { setupDatabaseStateVerification, type DatabaseState } from '../db-state';

describe('My test suite', () => {
  let initialState: DatabaseState;
  const { setupState, verifyState } = setupDatabaseStateVerification();

  beforeAll(async () => {
    initialState = await setupState();
  });

  afterAll(async () => {
    await verifyState(initialState);
  });

  // ... your tests ...
  // Tests can modify the database here, but verifyState will ensure
  // everything is restored to the original state
});
```